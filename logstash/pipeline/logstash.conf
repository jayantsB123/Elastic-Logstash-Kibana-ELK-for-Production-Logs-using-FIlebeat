input {
  beats {
    port => 5044
  }
}

filter {
  ruby {
    code => '
    begin
    raw = nil
    if event.get("event.original")
    raw = event.get("event.original")
    elsif event.get("message")
    raw = event.get("message")
    end

    if raw.is_a?(Array)
    raw = raw.join("\n")
    end

    event.set("raw_log", raw) if raw
    rescue => e
    event.tag("ruby_extract_failed")
    event.set("ruby_extract_error", e.message)
    end
    '
  }

  if ![raw_log] {
  mutate {
    add_tag => ["_no_raw_log"]
    add_field => { "parse_status" => "no_raw_log" }
  }
  drop { }
}

else if ([raw_log] =~ /^<log/ and [raw_log] =~ /<\/log>/) {
  grok {
    match => { "raw_log" => '<log realm="%{DATA:realm}" at="%{DATA:event_timestamp}" lifespan="%{DATA:lifespan_ms}ms"' }
    tag_on_failure => []
  }

  mutate {
    convert => { "lifespan_ms" => "integer" }
    add_tag => ["xml_parsed"]
  }

  if [realm] == "API" {
    grok {
      match => { "raw_log" => '<req>%{DATA:request_type}</req>\s*<inst>%{DATA:instance_id}</inst>\s*<api\.source>%{DATA:api_source}</api\.source>\s*<source>%{GREEDYDATA:client_source_raw}</source>\s*<clazz>%{DATA:dto_class}</clazz>' }
      tag_on_failure => []
    }
    if [client_source_raw] {
    json {
      source => "client_source_raw"
      target => "client_source"
      skip_on_invalid_json => true
    }
  }

  mutate {
    add_field => {
      "event_type" => "api_request"
      "log_level" => "INFO"
    }
    remove_field => ["client_source_raw"]
  }
}

else if [realm] == "cdci-channel-1" {
  grok {
    match => { "raw_log" => '<connect>%{GREEDYDATA:connection_text}</connect>' }
    tag_on_failure => []
  }

  if [connection_text] {
  grok {
    match => {
      "connection_text" => [
        "(?m)Try\s*%{INT:connection_attempt_number}\s*%{IPORHOST:destination_host}:%{INT:destination_port}.*Unable to connect",
        "(?m)%{IPORHOST:destination_host}:%{INT:destination_port}.*Unable to connect"
      ]
    }
    tag_on_failure => []
  }
}

mutate {
  add_field => {
    "event_type" => "connection"
    "log_level" => "WARN"
  }
  remove_field => ["connection_text"]
}
}


else if [realm] == "org.jpos.transaction.TransactionManager" {
  grok {
    match => { "raw_log" => '<context>%{GREEDYDATA:context_text}</context>' }
    tag_on_failure => []
  }

  if [context_text] {
    grok {
      match => {
        "context_text" => [
          "(?m)NODE_NAME:\s*%{DATA:node_name}",
          "(?m)TXNNAME:\s*%{DATA:ctx_TXNNAME}",
          "(?m)REQUEST_API:\s*%{DATA:ctx_REQUEST_API}",
          "(?m)HTTP_METHOD:\s*%{DATA:ctx_HTTP_METHOD}",
          "(?m)RAW_REQUEST:\s*%{GREEDYDATA:raw_request_json}",
          "(?m)API_SOURCE:\s*%{GREEDYDATA:api_source_json}",
          "(?m)TXN_RESPONSE:\s*%{GREEDYDATA:txn_response_json}",
          "(?m)SMS_RESPONSE:\s*%{GREEDYDATA:sms_response_json}",
          "(?m)RC:\s*%{DATA:ctx_RC}"
        ]
      }
      break_on_match => false
      tag_on_failure => []
    }

    grok {
      match => { "context_text" => 'LOGEVT:.*<info>%{GREEDYDATA:logevt_xml}</info>' }
      tag_on_failure => []
    }
  }

  if [raw_request_json] {
    json {
      source => "raw_request_json"
      target => "request_payload"
      skip_on_invalid_json => true
    }
  }

  if [api_source_json] {
    json {
      source => "api_source_json"
      target => "api_source_config"
      skip_on_invalid_json => true
    }
  }

  if [txn_response_json] {
    json {
      source => "txn_response_json"
      target => "txn_response"
      skip_on_invalid_json => true
    }
  }

  if [sms_response_json] {
    json {
      source => "sms_response_json"
      target => "sms_response"
      skip_on_invalid_json => true
    }
  }

  if [logevt_xml] {
    grok {
      match => {
        "logevt_xml" => [
          '<message>%{DATA:exception_message}</message>',
          '<detail>%{DATA:exception_detail}</detail>',
          '(?m)%{JAVACLASS:exception_class}: %{GREEDYDATA:exception_message_full}'
        ]
      }
      break_on_match => false
      tag_on_failure => []
    }
  }

  mutate {
    add_field => {
      "event_type" => "transaction"
      "log_level" => "INFO"
    }
    remove_field => [
      "context_text", "raw_request_json", "api_source_json",
      "txn_response_json", "sms_response_json", "logevt_xml"
    ]
  }
}

else {
  mutate {
    add_field => {
      "event_type" => "xml_parsed_unknown_realm"
      "log_level" => "UNKNOWN"
    }
  }
}

} else {
mutate {
  add_tag => ["incomplete_xml"]
  add_field => { "parse_status" => "incomplete_xml" }
}
drop { }
}

if [event_timestamp] {
mutate {
  gsub => ["event_timestamp", "\.\d+", ""]
}

date {
  match => [ "event_timestamp", "ISO8601" ]
  target => "@timestamp"
  timezone => "Asia/Kolkata"
}
}

mutate {
remove_field => ["raw_log"]
}

if ![event_type] {
mutate {
  add_field => {
    "event_type" => "unparsed"
    "log_level" => "UNKNOWN"
  }
  add_tag => ["_unparsed_log"]
}
}
}

output {
elasticsearch {
hosts => ["http://elasticsearch:9200"]
index => "jpos1-logs-%{+YYYY.MM.dd}"
user => "elastic"
password => "changeme"
}

stdout { codec => rubydebug }
}