input {
  beats {
    port => 5044
  }
}

filter {
  # Drop empty messages
  if ![message] or [message] == "" {
    drop { }
  }

  # Add ingestion timestamp
  mutate {
    add_field => { "ingested_at" => "%{+YYYY-MM-dd HH:mm:ss.SSS}" }
  }

  ##################################################
  # Phase 1: XML parsing
  ##################################################
  xml {
    source => "message"
    target => "xml_data"
    force_array => false
    remove_namespaces => true
    store_xml => false
    suppress_empty => true
    xpath => [
      "/log/@realm", "realm",
      "/log/@at", "event_timestamp",
      "/log/@lifespan", "lifespan_raw",
      "/log/info", "info_content",
      "/log/commit", "commit_content",
      "/log/connect", "connect_content"
    ]
  }

  ##################################################
  # Phase 2: Realm-specific parsing
  ##################################################
  if [realm] == "API" and [info_content] {
  xml {
    source => "info_content"
    target => "api_data"
    force_array => false
    remove_namespaces => true
    suppress_empty => true
    xpath => [
      "//req/text()", "api_request",
      "//inst/text()", "instance_id",
      "//api.source/text()", "api_source",
      "//clazz/text()", "dto_class"
    ]
  }

  mutate {
    add_field => {
      "log_type" => "api_request"
      "log_level" => "INFO"
    }
  }
}
else if [realm] == "cdci-channel-1" and [connect_content] {
grok {
  match => {
    "connect_content" => "Try\s+(?<connection_attempt>\d+)\s+(?<connection_target>\S+)(?:\s+(?<connection_status>.*))?"
  }
  tag_on_failure => ["_connection_parse_failed"]
}
mutate {
  convert => { "connection_attempt" => "integer" }
  add_field => {
    "log_type" => "connection"
    "log_level" => "INFO"
  }
}
}
else if [realm] == "org.jpos.transaction.TransactionManager" and [commit_content] {
  grok {
    match => { "commit_content" => "<context>(?<context_raw>.*?)</context>" }
  }

  grok {
    match => { "context_raw" => "NODE_NAME:\s*(?<node_name>[^\r\n]+)" }
  }
  grok {
    match => { "context_raw" => "TXNNAME:\s*(?<txn_name>[^\r\n]+)" }
  }
  grok {
    match => { "context_raw" => "REQUEST_API:\s*(?<api_request>[^\r\n]+)" }
  }
  grok {
    match => { "context_raw" => "HTTP_METHOD:\s*(?<http_method>[^\r\n]+)" }
  }
  grok {
    match => { "context_raw" => "RC:\s*(?<response_code>[^\r\n]+)" }
  }
  grok {
    match => { "context_raw" => "RAW_REQUEST:\s*(?<raw_request_json>\{.*\})" }
  }
  grok {
    match => { "context_raw" => "TXN_RESPONSE:\s*(?<txn_response_json>\{.*\})" }
  }

  json {
    source => "raw_request_json"
    target => "request_data"
    skip_on_invalid_json => true
  }
  json {
    source => "txn_response_json"
    target => "response_data"
    skip_on_invalid_json => true
  }

  mutate {
    add_field => {
      "log_type" => "transaction"
      "log_level" => "INFO"
    }
    remove_field => ["context_raw", "raw_request_json", "txn_response_json"]
  }
}

##################################################
# Phase 3: Normalize timestamps and lifespan
##################################################
date {
  match => [ "event_timestamp", "ISO8601" ]
  target => "@timestamp"
  timezone => "Asia/Kolkata"
}

if [lifespan_raw] {
  mutate {
    gsub => [ "lifespan_raw", "ms", "" ]
    convert => { "lifespan_raw" => "integer" }
    rename => { "lifespan_raw" => "lifespan_ms" }
  }
}

##################################################
# Phase 4: Cleanup and standardization
##################################################
mutate {
  strip => ["realm", "api_request", "node_name", "txn_name", "http_method", "response_code"]
  add_field => { "parsed_at" => "%{+YYYY-MM-dd HH:mm:ss.SSS}" }
}

# Tag unparsed logs
if ![log_type] {
  mutate {
    add_field => { "log_type" => "unparsed" }
    add_field => { "log_level" => "UNKNOWN" }
    add_tag => ["_xml_parse_failed"]
  }
}
}

output {
elasticsearch {
  hosts => ["http://elasticsearch:9200"]
  index => "jpos1-logs-%{+YYYY.MM.dd}"
  user => "elastic"
  password => "changeme"
  retry_on_conflict => 3
  timeout => 60
}

stdout { codec => rubydebug }
}
